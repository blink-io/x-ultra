package generator

import (
	"bufio"
	"bytes"
	"compress/gzip"
	"fmt"
	"go/parser"
	"go/printer"
	"go/token"
	"strconv"
	"strings"

	"github.com/blink-io/x/nats/cmd/protoc-gen-go-nats/internal/stringutils"
	"github.com/blink-io/x/nats/cmd/protoc-gen-go-nats/internal/typemap"

	"google.golang.org/protobuf/proto"
	descriptor "google.golang.org/protobuf/types/descriptorpb"
	plugin "google.golang.org/protobuf/types/pluginpb"
)

const (
	GEN_VERSION = "0.1.0"
)

type generator struct {
	filesHandled int

	reg *typemap.Registry

	pkgs          map[string]string
	pkgNamesInUse map[string]bool

	importPrefix string
	importMap    map[string]string

	sourceRelativePaths bool
	modulePrefix        string

	genPkgName          string
	fileToGoPackageName map[*descriptor.FileDescriptorProto]string

	genFiles []*descriptor.FileDescriptorProto

	output *bytes.Buffer
}

func Generate(in *plugin.CodeGeneratorRequest) (*plugin.CodeGeneratorResponse, error) {
	g := &generator{
		pkgs:                make(map[string]string),
		pkgNamesInUse:       make(map[string]bool),
		importMap:           make(map[string]string),
		fileToGoPackageName: make(map[*descriptor.FileDescriptorProto]string),
		output:              bytes.NewBuffer(nil),
	}

	params, err := parseInputParams(in.GetParameter())
	if err != nil {
		return nil, err
	}

	g.sourceRelativePaths = params.isSourceRelative()
	g.genFiles, err = filesToGenerate(in)
	if err != nil {
		return nil, err
	}

	g.reg = typemap.New(in.ProtoFile)
	g.registerPackageName("context")
	g.registerPackageName("http")
	g.registerPackageName("json")
	g.registerPackageName("fmt")
	g.registerPackageName("errors")
	g.registerPackageName("nats")
	g.registerPackageName("micro")

	genPkgName, err := deduceGenPkgName(g.genFiles)
	if err != nil {
		return nil, err
	}

	g.genPkgName = genPkgName

	genPkgImportPath, _, _ := goPackageOption(g.genFiles[0])

	// Next, we need to pick names for all the files that are dependencies.
	for _, f := range in.ProtoFile {
		// Is this is a file we are generating? If yes, it gets the shared package name.
		if fileDescSliceContains(g.genFiles, f) {
			g.fileToGoPackageName[f] = g.genPkgName
			continue
		}

		// Is this is an imported .proto file which has the same fully-specified
		// go_package as the targeted file for generation? If yes, it gets the
		// shared package name too.
		if genPkgImportPath != "" {
			importPath, _, _ := goPackageOption(f)
			if importPath == genPkgImportPath {
				g.fileToGoPackageName[f] = g.genPkgName
				continue
			}
		}

		// This is a dependency from a different go_package. Use its package name.
		name := f.GetPackage()
		if name == "" {
			name = stringutils.BaseName(f.GetName())
		}
		name = stringutils.CleanIdentifier(name)
		alias := g.registerPackageName(name)
		g.fileToGoPackageName[f] = alias
	}

	var resp plugin.CodeGeneratorResponse
	resp.SupportedFeatures = proto.Uint64(uint64(plugin.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL))

	for _, f := range g.genFiles {
		respFile := g.generate(f)
		if respFile != nil {
			resp.File = append(resp.File, respFile)
		}
	}

	return &resp, nil
}

func (g *generator) P(args ...string) {
	for _, v := range args {
		g.output.WriteString(v)
	}
	g.output.WriteByte('\n')
}

func (g *generator) generate(file *descriptor.FileDescriptorProto) *plugin.CodeGeneratorResponse_File {
	var resp plugin.CodeGeneratorResponse_File
	if len(file.Service) == 0 {
		return nil
	}

	g.generateFileHeader(file)
	g.generateImports(file)

	if g.filesHandled == 0 {
		g.generateUtilImports()
	}

	g.generateVersionCheck(file)

	// generate services
	for i, service := range file.Service {
		g.generateService(file, service, i)
	}

	if g.filesHandled == 0 {
		g.generateUtils()
	}

	g.generateFileDescriptor(file)

	resp.Name = proto.String(g.goFileName(file))
	resp.Content = proto.String(g.formattedOutput())
	g.output.Reset()

	g.filesHandled++

	return &resp
}

func (g *generator) generateFileHeader(file *descriptor.FileDescriptorProto) {
	g.P(`// Code generated by protoc-gen-nats `, GEN_VERSION, `, DO NOT EDIT.`)
	g.P(`// source: `, file.GetName())
	g.P()

	comment, err := g.reg.FileComments(file)
	if err == nil && comment.Leading != "" {
		for _, line := range strings.Split(comment.Leading, "\n") {
			if line != "" {
				g.P("// " + strings.TrimPrefix(line, " "))
			}
		}
		g.P()
	}

	g.P(`package `, g.genPkgName)
	g.P()
}

func (g *generator) generateVersionCheck(file *descriptor.FileDescriptorProto) {
	g.P(`// Version compatibility assertion.`)
	g.P(`// If the constant is not defined in the package, that likely means`)
	g.P(`// the package needs to be updated to work with this generated code.`)
	g.P(`const _ = `, g.pkgs["nats"], `.Version`) // probably needs to be gooder...
}

func (g *generator) generateFileDescriptor(file *descriptor.FileDescriptorProto) {
	// Copied straight of of protoc-gen-go, which trims out comments.
	pb := proto.Clone(file).(*descriptor.FileDescriptorProto)
	pb.SourceCodeInfo = nil

	b, err := proto.Marshal(pb)
	if err != nil {
		panic(err)
	}

	var buf bytes.Buffer
	w, _ := gzip.NewWriterLevel(&buf, gzip.BestCompression)
	_, _ = w.Write(b)
	w.Close()
	b = buf.Bytes()

	v := g.serviceMetadataVarName()
	g.P()
	g.P("var ", v, " = []byte{")
	g.P("	// ", fmt.Sprintf("%d", len(b)), " bytes of a gzipped FileDescriptorProto")
	for len(b) > 0 {
		n := 16
		if n > len(b) {
			n = len(b)
		}

		s := ""
		for _, c := range b[:n] {
			s += fmt.Sprintf("0x%02x,", c)
		}
		g.P(`	`, s)

		b = b[n:]
	}
	g.P("}")
}

// serviceMetadataVarName is the variable name used in generated code to refer
// to the compressed bytes of this descriptor. It is not exported, so it is only
// valid inside the generated package.
//
// protoc-gen-go writes its own version of this file, but so does
// protoc-gen-gogo - with a different name! NATS aims to be compatible with
// both; the simplest way forward is to write the file descriptor again as
// another variable that we control.
func (g *generator) serviceMetadataVarName() string {
	return fmt.Sprintf("natsFileDescriptor%d", g.filesHandled)
}

func (g *generator) registerPackageName(name string) (alias string) {
	alias = name
	i := 1
	for g.pkgNamesInUse[alias] {
		alias = name + strconv.Itoa(i)
		i++
	}
	g.pkgNamesInUse[alias] = true
	g.pkgs[name] = alias
	return alias
}

func (g *generator) formattedOutput() string {
	// Reformat generated code.
	fset := token.NewFileSet()
	raw := g.output.Bytes()
	ast, err := parser.ParseFile(fset, "", raw, parser.ParseComments)
	if err != nil {
		// Print out the bad code with line numbers.
		// This should never happen in practice, but it can while changing generated code,
		// so consider this a debugging aid.
		var src bytes.Buffer
		s := bufio.NewScanner(bytes.NewReader(raw))
		for line := 1; s.Scan(); line++ {
			fmt.Fprintf(&src, "%5d\t%s\n", line, s.Bytes())
		}
		panic(fmt.Errorf("bad Go source code was generated: %w %s", err, "\n"+src.String()))
	}

	out := bytes.NewBuffer(nil)
	err = (&printer.Config{Mode: printer.TabIndent | printer.UseSpaces, Tabwidth: 8}).Fprint(out, fset, ast)
	if err != nil {
		panic(fmt.Errorf("generated Go source code could not be reformatted: %w", err))
	}

	return out.String()
}

func filesToGenerate(req *plugin.CodeGeneratorRequest) ([]*descriptor.FileDescriptorProto, error) {
	genFiles := make([]*descriptor.FileDescriptorProto, 0)
Outer:
	for _, name := range req.FileToGenerate {
		for _, f := range req.ProtoFile {
			if f.GetName() == name {
				genFiles = append(genFiles, f)
				continue Outer
			}
		}
		return nil, fmt.Errorf("could not find file names %s", name)
	}

	return genFiles, nil
}

func parseInputParams(input string) (inputParams, error) {
	ip := inputParams{}

	for _, p := range strings.Split(input, ",") {
		if p == "" {
			continue
		}
		i := strings.Index(p, "=")
		if i < 0 {
			ip[p] = ""
			continue
		}

		ip[p[0:i]] = p[i+1:]
	}

	for k, v := range ip {
		switch {
		case len(k) > 0 && k[0] == 'M':

		case len(k) > 0 && strings.HasPrefix(k, "go_import_mapping@"):
			// TODO: handle import mappings

		case k == "paths":
			switch v {
			case "import":
			case "source_relative":
				ip["source_relative"] = v
			default:
				return nil, fmt.Errorf("invalid command line flag %s=%s", k, v)
			}

		case k == "module":
			// TODO: Handle module

		case k == "import_prefix":
			// TODO: handle import prefixes

		case k == "source_relative":

		default:
			return nil, fmt.Errorf("invalid command line flag %s=%s", k, v)
		}
	}

	return ip, nil
}

type inputParams map[string]string

func (ip inputParams) isSourceRelative() bool {
	_, found := ip["source_relative"]
	return found
}

// deduceGenPkgName figures out the go package name to use for generated code.
// Will try to use the explicit go_package setting in a file (if set, must be
// consistent in all files). If no files have go_package set, then use the
// protobuf package name (must be consistent in all files)
func deduceGenPkgName(genFiles []*descriptor.FileDescriptorProto) (string, error) {
	var genPkgName string
	for _, f := range genFiles {
		name, explicit := goPackageName(f)
		if explicit {
			name = stringutils.CleanIdentifier(name)
			if genPkgName != "" && genPkgName != name {
				// Make sure they're all set consistently.
				return "", fmt.Errorf("files have conflicting go_package settings, must be the same: %q and %q", genPkgName, name)
			}
			genPkgName = name
		}
	}
	if genPkgName != "" {
		return genPkgName, nil
	}

	// If there is no explicit setting, then check the implicit package name
	// (derived from the protobuf package name) of the files and make sure it's
	// consistent.
	for _, f := range genFiles {
		name, _ := goPackageName(f)
		name = stringutils.CleanIdentifier(name)
		if genPkgName != "" && genPkgName != name {
			return "", fmt.Errorf("files have conflicting package names, must be the same or overridden with go_package: %q and %q", genPkgName, name)
		}
		genPkgName = name
	}

	// All the files have the same name, so we're good.
	return genPkgName, nil
}

func fileDescSliceContains(slice []*descriptor.FileDescriptorProto, f *descriptor.FileDescriptorProto) bool {
	for _, sf := range slice {
		if f == sf {
			return true
		}
	}
	return false
}
